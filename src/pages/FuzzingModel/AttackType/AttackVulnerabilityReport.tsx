import React from "react";
import Card from "@mui/material/Card";
import MKTypography from "../../../components/MKTypography";
import Divider from "@mui/material/Divider";
import MKBox from "../../../components/MKBox";
import CircularProgress from "@mui/material/CircularProgress";
import Icon from "@mui/material/Icon";

export const dividerDiv = () => {
  return <Divider sx={ { my: 0.5, color: "black" } } />;
};

function reportForExtraction(data: any) {
  return (
    <>
      <MKTypography
        fontWeight="bold"
        style={ { color: "red" } }
        textAlign="left"
        sx={ { fontSize: "12px" } }
      >
        Alert: { data.overview.Alert }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Stolen Model Accuracy: { data.overview["Stolen Model Accuracy"] }{ " " }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Defense recommended: { data.overview["Defense recommended"] }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Original Model Accuracy:{ " " }
        { data.performance["Original Model Accuracy"] }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Number of test samples: { data.performance["Number of test samples"] }
      </MKTypography>
    </>
  );
}

function reportForInferenceOrEvasion(data: any) {
  return (
    <>
      <MKTypography
        fontWeight="bold"
        style={ { color: "red" } }
        textAlign="left"
        sx={ { fontSize: "12px" } }
      >
        Alert: { data.overview.Alert }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Adversarial Efficacy (max):{ " " }
        { data.overview["Adversarial Efficacy (max)"] }{ " " }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Defense recommended: { data.overview["Defense recommended"] }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Original Model Accuracy:{ " " }
        { data.performance["Original Model Accuracy"] }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Number of test samples: { data.performance["Number of test samples"] }
      </MKTypography>
    </>
  );
}

function reportForDataPoisoning(data: any) {
  return (
    <>
      <MKTypography
        fontWeight="bold"
        style={ { color: (data.overview.Alert === 'Low') ? "green" : 'red' } }
        textAlign="left"
        sx={ { fontSize: "12px" } }
      >
        Alert: { data.overview.Alert }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Poison Status:{ " " }
        { data.overview["Poison Status"] }{ " " }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Model under test Accuracy: { data.performance["Model under test Accuracy"] }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Model under test F1 score:{ " " }
        { data.performance["Model under test F1 score"] }
      </MKTypography>
      <MKTypography color="black" textAlign="left" sx={ { fontSize: "12px" } }>
        Number of test samples: { data.performance["Number of test samples"] }
      </MKTypography>
    </>
  );
}

function outcomeReport(data: any, name: string) {
  if (name === "Inference" || name === "Evasion") {
    return reportForInferenceOrEvasion(data);
  } else if (name === "Extraction") {
    return reportForExtraction(data);
  } else {
    return reportForDataPoisoning(data);
  }
}

function AttackSummary({ data, name }: any) {
  return (
    <MKBox pl={ 1 }>
      { outcomeReport(data, name) }
    </MKBox>
  );
}

function DataNotAvailable() {
  return (
    <MKTypography
      color="black"
      textAlign="center"
      variant="h6"
      sx={ { margin: "auto" } }
      p={ 3.3 }
    >
      Not Analyzed
    </MKTypography>
  );
}

function displayContent(
  report: any,
  keyvalue: any,
  attackTimmer: any,
  name: string
) {
  if (attackTimmer) {
    return (
      <CircularProgress
        style={ {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          margin: "auto"
        } }
        color="secondary"
        size={ 60 }
        thickness={ 4 }
      />
    );
  } else {
    if (report && Object.values(report).length > 0) {
      return (
        <div id={ keyvalue }>
          <AttackSummary data={ report } name={ name } />
        </div>
      );
    } else {
      return <DataNotAvailable />;
    }
  }
}

function AttackVulnerabilityReport({
  name,
  position,
  keyvalue,
  attackTimmer,
  report
}: any) {
  return (
    <Card
      style={ {
        width: "100%",
        marginTop: "13px",
        paddingBottom: "7px"
      } }
    >
      <MKTypography
        variant="h6"
        textAlign="center"
        sx={ { fontSize: "12px" } }
        color={ position.color }
      >
        { name }
        <Icon sx={ { fontSize: '1rem !important' } } title={ report?.overview?.Summary }>
          info
        </Icon>
      </MKTypography>
      { dividerDiv() }
      { displayContent(report, keyvalue, attackTimmer, name) }
    </Card>
  );
}

export default AttackVulnerabilityReport;
